import {
  BoxGeometry, 
  Mesh,
  PerspectiveCamera,
  Scene, 
  WebGLRenderer,
  MeshBasicMaterial,
  DoubleSide,
  Color,
  PlaneGeometry,
  DataTexture,
  RGBAFormat,
  ByteType,
  WebGLRenderTarget,
  ShaderMaterial,
  OrthographicCamera
} from 'three';

let camera, scene, renderer, material, textureA, textureB;

class App {

  init() {

//    camera = new PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 300 );
//    camera.position.z = 5;
    camera = new OrthographicCamera( -128, 128, 128, -128, .1, 1000 );
    camera.position.z = 5;

    scene = new Scene();
    scene.background = new Color( 0x50f000 );
    
    renderer = new WebGLRenderer();
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    window.addEventListener('resize', onWindowResize, false );

    const len = 256 * 256 * 4;
    const data = new Uint8Array(len);
    for ( let i = 0; i++; i<100 ){
      data[i*4] = 255;
      console.log(i);
    }
    const dataTex = new DataTexture( data, 256, 256, RGBAFormat, ByteType );

    textureA = new WebGLRenderTarget( 256, 256 );
    textureB = new WebGLRenderTarget( 256, 256 );

    let vShader = require('./glsl/vertex.glsl');
    let fShader = require('./glsl/fragment.glsl');

    const geometry = new PlaneGeometry( 256, 256 );
    material = new ShaderMaterial( {
      uniforms: {
        fire: { type: "t", value: dataTex }
      },
      vertexShader: vShader,
      fragmentShader: fShader
    } );
    const plane = new Mesh( geometry, material );
    
    scene.add( plane );

    renderer.render( scene, camera );
  }
}

function onWindowResize() {

  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  renderer.setSize( window.innerWidth, window.innerHeight );

}

function animate() {

  requestAnimationFrame( animate );
  renderer.render( scene, camera );

}

export { App }
